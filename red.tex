\begin{Interfaz}
  
  \textbf{se explica con}: \tadNombre{Red}.

  
  \section*{Operaciones básicas de \tadNombre{Red}}

  \InterfazFuncion{IniciarRed}{}{red}
  {$res \igobs iniciarRed()$}
  [$\Theta()$]
  [genera la red vacía]

  \InterfazFuncion{AgregarComputadora}{\Inout{r}{\tadNombre{Red}}, \In{c}{\tadNombre{Compu}}}{}
  [$r \igobs r_0 \land (\forall c' : compu) (c' \in computadoras(r) \impluego ip(c) \neq ip(c'))$] 
  {$computadoras(r) = Ag(c, computadoras(r_0)) \yluego \\
     (\forall c_1, c_2 : compu) (c_1 \in computadoras(r_0) \land c_2 \in computadoras(r_0) \impluego \\ 
   conectadas(r_0, c_1, c_2) = conectadas(r, c_1, c_2) \land interfazUsada(r_0, c_1, c_2) = interfazUsada(r, c_1, c_2)$)}
  [$\Theta()$]
  [agrega el la computadora $c$ a la red $r$.]
  [el elemento $c$ agrega por copia.]
  
  
  \InterfazFuncion{conectar}{\Inout{r}{\tadNombre{Red}}, \In{c_1}{\tadNombre{Compu}},  \In{i_1}{\tadNombre{Interfaz}}, \In{c_2}{\tadNombre{Interfaz}}, \In{i_2}{\tadNombre{Interfaz}}}{}
 [$r \igobs r_0 \land c_1 \in computadoras(r) \land c_2 \in computadoras(r) \land ip(c_1) \neq ip(c_2) \land \neg conectadas?(r, c_1, c_2) \land \neg usaInterfaz?(r,c_1, i_1) \land \neg usaInterfaz?(r, c_2, i_2)$]
  {$computadoras(r) = computadoras(r_0) \yluego \\
    (\forall c'_1, c'_2 : compu) (c'_1 \in computadoras(r_0) \land c'_2 \in computadoras(r_0) \land \{c_1, c_2\} \neq \{c'_1, c'_2\} \impluego \\ 
   conectadas(r_0, c'_1, c'_2) = conectadas(r, c'_1, c'_2) \land interfazUsada(r_0, c'_1, c'_2) = interfazUsada(r, c'_1, c'_2)) \land \\
   conectadas(r_0, c_1, c_2) \land interfazUsada(r, c_1, c_2) = i_1 \land interfazUsada(r, c_2, c_1) = i_2$}
  [$\Theta()$]
  [conecta las computadoras $c_1$ y $c_2$ mediante las interfaces $i_1$ e $i_2$ respectivamente en la red $r$.]


  \InterfazFuncion{computadoras}{\In{r}{\tadNombre{Red}}}{}
  {$res = computadoras(r)$}
  [$\Theta()$]
  [devuelve un conjunto con todas las computadoras de la red $r$.]
  [?]


  \InterfazFuncion{conectadas?}{\In{r}{\tadNombre{Red}}, \In{c_1}{\tadNombre{Compu}}, \In{c_2}{\tadNombre{Compu}}}{\tadNombre{bool}}
  [$c_1 \in computadoras(r) \land c_2 \in computadoras(r)$]
  {$res = conectadas?(r,c_1,c_2)$}
  [$\Theta()$]
  [dice si las computadoras $c_1$ y $c_2$ están conectadas en la red $r$]


  \InterfazFuncion{interfazUsada}{\In{r}{\tadNombre{Red}}, \In{c_1}{\tadNombre{Compu}}, \In{c_2}{\tadNombre{Compu}}}{\tadNombre{bool}}
  [$conectadas?(r,c_1,c_2)$]
  {$res = interfazUsada(r,c_1,c_2)$}
  [$\Theta()$]
  [devuelve la interfaz mediante la cual $c_1$ se conecta a $c_2$  en la red $r$.]


\end{Interfaz}

\begin{Representacion}
  
  \section*{Representación de la lista}

  \begin{Estructura}{lista$(\alpha)$}[lst]
    \begin{Tupla}[lst]
      \tupItem{primero}{puntero(nodo)}%
      \tupItem{longitud}{nat}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItem{dato}{$\alpha$}%
      \tupItem{anterior}{puntero(nodo)}%
      \tupItem{siguiente}{puntero(nodo)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[lst][l]{($l$.primero $=$ NULL) $=$ ($l$.longitud $=$ $0$) $\yluego$ ($l$.longitud $\neq$ $0$ \impluego \\
    Nodo($l$, $l$.longitud) $=$ $l$.primero $\land$ \\
    ($\forall i$: nat)(Nodo($l$,$i$)\DRef siguiente $=$ Nodo($l$,$i+1$)\DRef anterior) $\land$ \\
    ($\forall i$: nat)($1 \leq i <$ $l$.longitud $\implies$ Nodo($l$,$i$) $\neq$ $l$.primero)}\mbox{}

  ~      

  \tadOperacion{Nodo}{lst/l,nat}{puntero(nodo)}{$l$.primero $\neq$ NULL}
  \tadAxioma{Nodo($l$,$i$)}{\IF $i = 0$ THEN $l$.primero ELSE Nodo(FinLst($l$), $i-1$) FI}

  ~

  \tadOperacion{FinLst}{lst}{lst}{}
  \tadAxioma{FinLst($l$)}{Lst($l$.primero\DRef siguiente, $l$.longitud $-$ $\min$\{$l$.longitud, $1$\})}

  ~

  \tadOperacion{Lst}{puntero(nodo),nat}{lst}{}
  \tadAxioma{Lst($p,n$)}{$\langle p, n\rangle$}

  ~
 
  \AbsFc[lst]{secu($\alpha$)}[l]{\IF $l$.longitud $=$ $0$ THEN \secuencia{} ELSE \secuencia{$l$.primero\DRef dato}[Abs(FinLst($l$))] FI}

  \section*{Representación del iterador}

  \begin{Estructura}{itLista($\alpha$)}[iter]
    \begin{Tupla}[iter]
      \tupItem{siguiente}{puntero(nodo)}%
      \tupItem{lista}{puntero(lst)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[iter][it]{Rep($\ast$($it$.lista)) $\yluego$ ($it$.siguiente $=$ NULL $\oluego$ ($\exists i$: nat)(Nodo($\ast it$.lista, $i$) $=$ $it$.siguiente)}

  ~

  \Abs[iter]{itBi($\alpha$)}[it]{b}{Siguientes($b$) $=$ Abs(Sig($it$.lista, $it$.siguiente)) $\land$\\
    Anteriores($b$) $=$ Abs(Ant($it$.lista, $it$.siguiente))}

  ~

  \tadOperacion{Sig}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Sig($i, p$)}{Lst($p$, $l$\DRef longitud $-$ Pos($\ast l$, $p$))}

  ~

  \tadOperacion{Ant}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Ant($i, p$)}{Lst(\IF $p$ $=$ $l$\DRef primero THEN NULL ELSE $l$\DRef primero FI, Pos($\ast l$, $p$))}

  ~

  {\small Nota: cuando $p$ $=$ NULL, Pos devuelve la longitud de la lista, lo cual está bien, porque significa que el iterador no tiene siguiente.}
  \tadOperacion{Pos}{lst/l,puntero(nodo)/p}{puntero(nodo)}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Pos($l$,$p$)}{\IF $l$.primero $=$ $p$ $\lor$ $l$.longitud $=$ $0$ THEN $0$ ELSE $1$ $+$ Pos(FinLst($l$), $p$) FI}


\end{Representacion}
