\begin{Interfaz}
  
  \textbf{se explica con}: \tadNombre{dcnet}.

  \textbf{géneros}: \TipoVariable{dcnet}.

  \section*{Operaciones básicas de DCNet}

  \InterfazFuncion{IniciarDCNet}{\In{r}{\tadNombre{red}}}{\tadNombre{dcnet}}
  [ $True$ ]
  {$ res \igobs IniciarDCNet(r)  $ }
  [$\Theta(1)$]
  [Genera una DCNet con las computadoras y conexiones de la red pasada como parámetro.]

  \InterfazFuncion{CrearPaquete}{\Inout{s}{\tadNombre{dcnet}}, \In{p}{\tadNombre{paquete}}}{}
  [$s \igobs s_0 \land 
   \neg((\exists p':paquete) (paqueteEnTransito?(s_0,p') \land id(p') \igobs id(p)) \land\\ 
   \hspace*{3em} origen(p) \in computadoras(red(s_0)) \yluego
   destino(p) \in computadoras(red(s_0)) \yluego\\
   \hspace*{3em} hayCamino?(red(s), origen(p), destino(p))$]
  {$s \igobs crearPaquete(s_0, p)$}
  [$\Theta()$]
  [Agrega el paquete $p$ a la cola de la computadora $p.origen$.]
  
  \InterfazFuncion{AvanzarSegundo}{\Inout{s}{\tadNombre{dcnet}}}{\tadNombre{dcnet}}
  [$s \igobs s_0$]  
  {$res \igobs avanzarSegundo(s_0)$}
  [$\Theta()$]
  [Avanza un segundo; todas las computadoras que tengan paquetes por enviar los envían.]
  
  
  \InterfazFuncion{red}{\In{s}{\tadNombre{dcnet}}}{\tadNombre{red}}
  [$ True $]  
  {$res \igobs red(s_0)$}
  [$\Theta(1)$]
  [Expresa la red que esta contenida en la DCNet.]}

  
  \InterfazFuncion{caminoRecorrido}{\In{s}{\tadNombre{dcnet}}, \In{p}{\tadNombre{paquete}}}{\tadNombre{secu(compu)}}
  [$ paqueteEnTransito?(s,p) $]
  {$res \igobs caminoRecorrido(s, p)$}
  [$\Theta()$]
  [Expresa el camino de computadoras recorrido por el paquete "p" desde su inicio hasta posicion actual.]


  \InterfazFuncion{cantidadEnviados}{\In{s}{\tadNombre{dcnet}}, \In{c}{\tadNombre{compu}}}{\tadNombre{nat}}
  [$ c \in computadoras(red(s)) $]  
  {$res \igobs cantidadEnviados(s, c)$}
  [$\Theta()$]
  [Expresa la cantidad de mensajes enviados por la compu "c".]

  
  \InterfazFuncion{enEspera}{\In{s}{\tadNombre{dcnet}}, \In{c}{\tadNombre{compu}}}{\tadNombre{conj(paquete)}}
  [$ c \in computadoras(red(s)) $]  
  {$res \igobs enEspera(s, c)$}
  [$\Theta()$]
  [Expresa el camino de computadoras recorrido por el paquete "p" desde su inicio hasta posicion actual.]


  \InterfazFuncion{PaqueteEnTransito}{\In{s}{\tadNombre{dcnet}}, \In{p}{\tadNombre{paquete}}}{\tadNombre{bool}}
  [$ True $]  
  {$res \igobs paqueteEnTransito?(s, p)$}
  [$\Theta()$]
  [Expresa si el paquete "p" esta en alguna computadora.]
  
  
  \InterfazFuncion{LaQueMasEnvio}{\In{s}{\tadNombre{dcnet}}}{\tadNombre{compu}}
  [$ True $]
  {$res \igobs laQuemasEnvio(s)$}
  [$\Theta(1)$]
  [Devuelve la computadora que mas paquetes envio.]

  
  \section*{Operaciones del iterador}

  \InterfazFuncion{CrearIt}{\In{l}{lista($\alpha$)}}{itLista($\alpha$)}
  {$res$ $\igobs$ crearItBi(\secuencia{}, $l$) $\land$ alias(SecuSuby($it$) $=$ $l$)}
  [$\Theta(1)$]
  [crea un iterador bidireccional de la lista, de forma tal que al pedir \NombreFuncion{Siguiente} se obtenga el primer elemento de $l$.]
  [el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]
  
  \InterfazFuncion{CrearItUlt}{\In{l}{lista($\alpha$)}}{itLista($\alpha$)}
  {$res$ $\igobs$ crearItBi($l$, \secuencia{}) $\land$ alias(SecuSuby($it$) $=$ $l$)}
  [$\Theta(1)$]
  [crea un iterador bidireccional de la lista, de forma tal que al pedir \NombreFuncion{Anterior} se obtenga el último elemento de $l$.]  
  [el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]

\end{Interfaz}

\begin{Representacion}
  
  \section*{Representación de DCNet}

  \begin{Estructura}{lista$(\alpha)$}[lst]
    \begin{Tupla}[lst]
      \tupItem{primero}{puntero(nodo)}%
      \tupItem{longitud}{nat}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItem{dato}{$\alpha$}%
      \tupItem{anterior}{puntero(nodo)}%
      \tupItem{siguiente}{puntero(nodo)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[lst][l]{($l$.primero $=$ NULL) $=$ ($l$.longitud $=$ $0$) $\yluego$ ($l$.longitud $\neq$ $0$ \impluego \\
    Nodo($l$, $l$.longitud) $=$ $l$.primero $\land$ \\
    ($\forall i$: nat)(Nodo($l$,$i$)\DRef siguiente $=$ Nodo($l$,$i+1$)\DRef anterior) $\land$ \\
    ($\forall i$: nat)($1 \leq i <$ $l$.longitud $\implies$ Nodo($l$,$i$) $\neq$ $l$.primero)}\mbox{}

  ~      

  \tadOperacion{Nodo}{lst/l,nat}{puntero(nodo)}{$l$.primero $\neq$ NULL}
  \tadAxioma{Nodo($l$,$i$)}{\IF $i = 0$ THEN $l$.primero ELSE Nodo(FinLst($l$), $i-1$) FI}

  ~

  \tadOperacion{FinLst}{lst}{lst}{}
  \tadAxioma{FinLst($l$)}{Lst($l$.primero\DRef siguiente, $l$.longitud $-$ $\min$\{$l$.longitud, $1$\})}

  ~

  \tadOperacion{Lst}{puntero(nodo),nat}{lst}{}
  \tadAxioma{Lst($p,n$)}{$\langle p, n\rangle$}

  ~
 
  \AbsFc[lst]{secu($\alpha$)}[l]{\IF $l$.longitud $=$ $0$ THEN \secuencia{} ELSE \secuencia{$l$.primero\DRef dato}[Abs(FinLst($l$))] FI}

  \section*{Representación del iterador}

  \begin{Estructura}{itLista($\alpha$)}[iter]
    \begin{Tupla}[iter]
      \tupItem{siguiente}{puntero(nodo)}%
      \tupItem{lista}{puntero(lst)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[iter][it]{Rep($\ast$($it$.lista)) $\yluego$ ($it$.siguiente $=$ NULL $\oluego$ ($\exists i$: nat)(Nodo($\ast it$.lista, $i$) $=$ $it$.siguiente)}

  ~

  \Abs[iter]{itBi($\alpha$)}[it]{b}{Siguientes($b$) $=$ Abs(Sig($it$.lista, $it$.siguiente)) $\land$\\
    Anteriores($b$) $=$ Abs(Ant($it$.lista, $it$.siguiente))}

  ~

  \tadOperacion{Sig}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Sig($i, p$)}{Lst($p$, $l$\DRef longitud $-$ Pos($\ast l$, $p$))}

  ~

  \tadOperacion{Ant}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Ant($i, p$)}{Lst(\IF $p$ $=$ $l$\DRef primero THEN NULL ELSE $l$\DRef primero FI, Pos($\ast l$, $p$))}

  ~

  {\small Nota: cuando $p$ $=$ NULL, Pos devuelve la longitud de la lista, lo cual está bien, porque significa que el iterador no tiene siguiente.}
  \tadOperacion{Pos}{lst/l,puntero(nodo)/p}{puntero(nodo)}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Pos($l$,$p$)}{\IF $l$.primero $=$ $p$ $\lor$ $l$.longitud $=$ $0$ THEN $0$ ELSE $1$ $+$ Pos(FinLst($l$), $p$) FI}


\end{Representacion}



\begin{Algoritmos}


\begin{algorithm}
  \caption{Algoritmos de \tadNombre{DCNet}}


\begin{algorithmic}[1]
  \Procedure{Iniciar() $\to res$ : dcnet}{}
  \State Falta agregarlo
  \EndProcedure
\end{algorithmic}


%\caption{CrearPaquete}
\begin{algorithmic}[1]
  \Procedure{CrearPaquete(\textbf{in/out} $s$ : dcnet, \textbf{in} $p$ : paquete) $\to res$ : dcnet}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}


%\caption{AvanzarSegundo}
\begin{algorithmic}[1]
  \Procedure{AvanzarSegundo(\textbf{in/out} $s$ : dcnet)}{}
  \State Falta agregarlo
 \EndProcedure
\end{algorithmic}

%\caption{red}
\begin{algorithmic}[1]
  \Procedure{red(\textbf{in} $s$ : dcnet)}{}
 \State Falta agregarlo
 \EndProcedure
\end{algorithmic}


%\caption{caminoRecorrido}
\begin{algorithmic}[1]
  \Procedure{caminoRecorrido(\textbf{in} $s$ : dcnet, \textbf{in} $p$ : paquete) $\to res$ : secu(compu)}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}

%\caption{cantidadEnviados}
\begin{algorithmic}[1]
  \Procedure{cantidadEnviados(\textbf{in} $s$ : dcnet, \textbf{in} $c$ : compu)  $\to res$ : nat}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}

%\caption{enEspera}
\begin{algorithmic}[1]
  \Procedure{enEspera(\textbf{in} $s$ : dcnet, \textbf{in} $c$ : compu)  $\to res$ : conj(paquete)}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}

%\caption{paqueteEnTransito}
\begin{algorithmic}[1]
  \Procedure{paqueteEnTransito(\textbf{in} $s$ : dcnet, \textbf{in} $p$ : paquete)  $\to res$ : bool}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}

%\caption{laQueMasEnvio}
\begin{algorithmic}[1]
  \Procedure{enEspera(\textbf{in} $s$ : dcnet)  $\to res$ : compu}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}


\end{algorithm}



\end{Algoritmos}

