\begin{Interfaz}
  
  \textbf{se explica con}: \tadNombre{dcnet}.

  \textbf{géneros}: \TipoVariable{dcnet}.

  \section*{Operaciones básicas de DCNet}

  \InterfazFuncion{IniciarDCNet}{\In{r}{\tadNombre{red}}}{\tadNombre{dcnet}}
  [ $True$ ]
  {$ res \igobs IniciarDCNet(r)  $ }
  [$\Theta(1)$]
  [Genera una DCNet con las computadoras y conexiones de la red pasada como parámetro.]

  \InterfazFuncion{CrearPaquete}{\Inout{s}{\tadNombre{dcnet}}, \In{p}{\tadNombre{paquete}}}{}
  [$s \igobs s_0 \land 
   \neg((\exists p':paquete) (paqueteEnTransito?(s_0,p') \land id(p') \igobs id(p)) \land\\ 
   \hspace*{3em} origen(p) \in computadoras(red(s_0)) \yluego
   destino(p) \in computadoras(red(s_0)) \yluego\\
   \hspace*{3em} hayCamino?(red(s), origen(p), destino(p))$]
  {$s \igobs crearPaquete(s_0, p)$}
  [$\Theta()$]
  [Agrega el paquete $p$ a la cola de la computadora $p.origen$.]
  
  \InterfazFuncion{AvanzarSegundo}{\Inout{s}{\tadNombre{dcnet}}}{}
  [$s \igobs s_0$]  
  {$res \igobs avanzarSegundo(s_0)$}
  [$\Theta()$]
  [Avanza un segundo; todas las computadoras que tengan paquetes por enviar los envían.]
  
  
  \InterfazFuncion{red}{\In{s}{\tadNombre{dcnet}}}{\tadNombre{red}}
  [$ True $]  
  {$res \igobs red(s_0)$}
  [$\Theta(1)$]
  [Expresa la red que esta contenida en la DCNet.]

  
  \InterfazFuncion{caminoRecorrido}{\In{s}{\tadNombre{dcnet}}, \In{p}{\tadNombre{paquete}}}{\tadNombre{secu(compu)}}
  [$ paqueteEnTransito?(s,p) $]
  {$res \igobs caminoRecorrido(s, p)$}
  [$\Theta()$]
  [Expresa el camino de computadoras recorrido por el paquete "p" desde su inicio hasta posicion actual.]


  \InterfazFuncion{cantidadEnviados}{\In{s}{\tadNombre{dcnet}}, \In{c}{\tadNombre{compu}}}{\tadNombre{nat}}
  [$ c \in computadoras(red(s)) $]  
  {$res \igobs cantidadEnviados(s, c)$}
  [$\Theta()$]
  [Expresa la cantidad de mensajes enviados por la compu "c".]

  
  \InterfazFuncion{enEspera}{\In{s}{\tadNombre{dcnet}}, \In{c}{\tadNombre{compu}}}{\tadNombre{conj(paquete)}}
  [$ c \in computadoras(red(s)) $]  
  {$res \igobs enEspera(s, c)$}
  [$\Theta()$]
  [Expresa el camino de computadoras recorrido por el paquete "p" desde su inicio hasta posicion actual.]


  \InterfazFuncion{PaqueteEnTransito}{\In{s}{\tadNombre{dcnet}}, \In{p}{\tadNombre{paquete}}}{\tadNombre{bool}}
  [$ True $]  
  {$res \igobs paqueteEnTransito?(s, p)$}
  [$\Theta()$]
  [Expresa si el paquete "p" esta en alguna computadora.]
  
  
  \InterfazFuncion{LaQueMasEnvio}{\In{s}{\tadNombre{dcnet}}}{\tadNombre{compu}}
  [$ True $]
  {$res \igobs laQuemasEnvio(s)$}
  [$\Theta(1)$]
  [Devuelve la computadora que mas paquetes envio.]
  

\end{Interfaz}

\begin{Representacion}
  
  \section*{Representación de DCNet}

  \begin{Estructura}{dcnet}[net]
    \begin{Tupla}[net]
      \tupItem{proximaEnCamino}{dicc(id, dicc(id, id))}%
      \tupItem{\\ paquetes}{diccTrie(id,infoPaquetes)}%
      \tupItem{\\ caminosRecorridos}{lista(lista(id))}
      \tupItem{\\ laQueMasEnvio}{tupla($cuantosEnvio$ : nat, $cualCompu$ : id)}
      \tupItem{\\ red}{red}
    \end{Tupla}
  
  
  \begin{Tupla}[infoPaquetes]
      \tupItem{colas}{colaPrior(tupla($p$ : paq, $camino$ : itLista))}
      \tupItem{conjPaquetes}{conj(paq)}
      \tupItem{cantEnviados}{nat}                       
    \end{Tupla}
  \end{Estructura}


  \Rep[lst][l]{($l$.primero $=$ NULL) $=$ ($l$.longitud $=$ $0$) $\yluego$ ($l$.longitud $\neq$ $0$ \impluego \\
    Nodo($l$, $l$.longitud) $=$ $l$.primero $\land$ \\
    ($\forall i$: nat)(Nodo($l$,$i$)\DRef siguiente $=$ Nodo($l$,$i+1$)\DRef anterior) $\land$ \\
    ($\forall i$: nat)($1 \leq i <$ $l$.longitud $\implies$ Nodo($l$,$i$) $\neq$ $l$.primero)}\mbox{}


  \AbsFc[lst]{secu($\alpha$)}[l]{\IF $l$.longitud $=$ $0$ THEN \secuencia{} ELSE \secuencia{$l$.primero\DRef dato}[Abs(FinLst($l$))] FI}

\end{Representacion}



\begin{Algoritmos}


\begin{algorithm}
  \caption{Algoritmos de \tadNombre{DCNet}}


\begin{algorithmic}[1]
  \Procedure{Iniciar(\textbf{in} $r$ : red) $\to res$ : dcnet}{}
  \State $red \gets r$  PREGUNTAR COPIA/ALIAS
  \State $caminosRecorridos \gets$ Vacia()
  \State $laQueMasEnvio \gets$ (0, NULL)
  \State conj(compu) $compus \gets$ Computadoras($red$)
  \State itConj $it \gets$ CrearIt($compus$)
  \State $proximaEnCamino \gets$ Vacio()
  \While{HaySiguiente?(it)}
    \State \tadNombre{itConj} $it2 \gets$ CrearIt($compus$)
    \State diccTrie(id, puntero(compu)) $diccActual \gets$ Vacio()
    \While{HaySiguiente?(it2)}
      \State conj(lista(compu)) $camMinimos \gets$ CaminosMinimos(red, SiguienteClave(it), SiguienteClave(it2))
      \State itConj $it3 \gets$ CrearIt(camMinimos)
      \State $caminoMinimo \gets$ siguiente(it3)
      \State Fin(caminoMinimo)
      \State puntero(compu) $siguiente \gets$ \& Primero($caminoMinimo$)
      \State Definir($diccActual$, SiguienteClave(it2), id($siguiente$))
      \State Avanzar(it3)            
    \EndWhile
    \State definir($proximaEnCamino$, id(SiguienteClave($it$), $diccActual$)))
    \State Avanzar($it2$)
  \EndWhile
   
  \EndProcedure
\end{algorithmic}


%\caption{CrearPaquete}
\begin{algorithmic}[1]
  \Procedure{CrearPaquete(\textbf{in/out} $s$ : dcnet, \textbf{in} $p$ : paquete)}{}
   \State lista(compu) $nuevoCaminoRecorrido \gets$ Vacio()
   \State AgregarAtras(nuevoCaminoRecorrido, origen(p))
   \State itLista(lista(compu)) $it \gets$ AgregarAtras(caminosRecorridos, nuevoCaminoRecorrido)
   \State $losPaquetes \gets $ Obtener($paquetes$, id(p.origen))
   \State Encolar(losPaquetes.cola, ($p$, $it$))
   \State Agregar(losPaquetes.conjPaquetes, $p$)
  \EndProcedure
\end{algorithmic}


%\caption{AvanzarSegundo}
\begin{algorithmic}[1]
  \Procedure{AvanzarSegundo(\textbf{in/out} $s$ : dcnet)}{}
  
  \State lista(tupla(paq, itLista(lista(id)))) $paquetesAEnviar \gets$ Vacio()
  
  \State itDiccTrie $it \gets$ CrearIt($paquetes$)
  \While{HaySiguientes?(it)}
  	\State infoCompu $s \gets$ SiguienteSignificado($it$) 
  	\If{$\neg$Vacía?($s$.$cola$)}
  		\State tupla(paquete,itLista(lista(id))) $estePaquete \gets$ Desencolar($s$.$cola$)
  		%\State tupla(paquete, itLista) $paqEIt \gets$ Obtener($s$.conjPaquetes, $x$)
  		\State Eliminar($s$.conjPaquetes, $\pi_0(x)$)
      		
		%\State tupla(puntero(paquete), itLista) $infoPaquete \gets$ (\& $\pi_0$(paqEIt), $\pi_1$(paqEIt))
		\State AgregarAtras(paquetesAEnviar($estePaquete$))
		\State cantEnviados++
		\If{$s$.cantEnviados > laQueMasEnvio.cuantosEnvio}
		   \State $laQueMasEnvio.cuantosEnvio \gets$ $s$.cantEnviados
		   \State $laQueMasEnvio.cualCompu \gets$ ultimo(Siguiente($pi_1$($estePaquete$)))
		\EndIf
	\EndIf
	\State Avanzar($it$)
  \EndWhile 
   
  \State itLista(tupla(paq, itLista(lista(id)))) $it_2 \gets$ CrearIt($paquetesAEnviar$)
  \While{HaySiguientes?($it_2$)}
      \State tupla(paq, itLista(lista(id)) $p \gets$ Siguiente($it_2$)
      \State id $proximaCompu \gets$ Obtener($proximaEnCamino$, $Ultimo(Siguiente(\pi_1(p)))$, destino($p$))
      \State $paquetesDeProximaCompu \gets$ Obtener($paquetes$, proximaCompu)
      \State AgregarAtras(Siguiente($\pi_1(p)$), proximaCompu)
      \State Encolar($paquetesDeProximaCompu$.$cola$, p)
      \State Agregar($paquetesDeProximacompu$.$conjPaquetes$, $\pi_0$(p))
      \State Avanzar($it_2$)
  \EndWhile
 
 \EndProcedure
\end{algorithmic}

%\caption{red}
\begin{algorithmic}[1]
  \Procedure{red(\textbf{in} $s$ : dcnet)}{}
 \State Falta agregarlo
 \EndProcedure
\end{algorithmic}


%\caption{caminoRecorrido}
\begin{algorithmic}[1]
  \Procedure{caminoRecorrido(\textbf{in} $s$ : dcnet, \textbf{in} $p$ : paquete) $\to res$ : secu(compu)}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}

%\caption{cantidadEnviados}
\begin{algorithmic}[1]
  \Procedure{cantidadEnviados(\textbf{in} $s$ : dcnet, \textbf{in} $c$ : compu)  $\to res$ : nat}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}

%\caption{enEspera}
\begin{algorithmic}[1]
  \Procedure{enEspera(\textbf{in} $s$ : dcnet, \textbf{in} $c$ : compu)  $\to res$ : conj(paquete)}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}

%\caption{paqueteEnTransito}
\begin{algorithmic}[1]
  \Procedure{paqueteEnTransito(\textbf{in} $s$ : dcnet, \textbf{in} $p$ : paquete)  $\to res$ : bool}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}

%\caption{laQueMasEnvio}
\begin{algorithmic}[1]
  \Procedure{enEspera(\textbf{in} $s$ : dcnet)  $\to res$ : compu}{}
   \State Falta agregarlo
  \EndProcedure
\end{algorithmic}


\end{algorithm}



\end{Algoritmos}

